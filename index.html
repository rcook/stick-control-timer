<!DOCTYPE html>
<html>

<head>
  <title>Stick Control Metronome</title>
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: Verdana, Geneva, Tahoma, sans-serif;
      margin: 0px;
      display: flex;
      height: 100vh;
      align-items: center;
      background-color: limegreen;
    }

    body.last {
      animation: blink 0.75s linear infinite;
    }

    @keyframes blink {
      0% {
        background-color: white;
      }

      50% {
        background-color: red;
      }

      100% {
        background-color: white;
      }
    }

    #container {
      width: fit-content;
      margin: 0 auto;
    }

    .dots {
      display: flex;
      min-width: 900px;
      height: 200px;
    }

    .dot {
      width: 125px;
      height: 125px;
      border-radius: 50%;
      border: 5px solid green;
      display: grid;
      align-items: center;
      text-align: center;
      font-size: 2em;
      margin: 20px;
      color: lime;
    }

    .current {
      background-color: lightgreen;
      color: darkgreen;
    }

    #progress-repetitions,
    #progress-bars {
      font-size: 5em;
    }

    #controls {
      display: flex;
    }

    #fields {
      display: inline;
      border: none;
    }

    #fields div {
      display: inline-block;
    }

    #fields label {
      display: block;
    }

    #fields input,
    #fields select {
      box-sizing: border-box;
      vertical-align: top;
      height: 32px;
      padding: 5px;
    }

    #buttons {
      align-content: center;
    }

    #buttons button {
      height: 32px;
    }

    #progress-exercise {
      font-size: 3em;
    }

    #progress-repetition,
    #progress-bar {
      font-size: 2em;
    }

    #preset-container {
      display: none !important;
    }
  </style>
</head>

<body>
  <div id="container">
    <div id="indicators">
      <div id="progress-exercise">&ndash;&ndash;&ndash;</div>
      <div id="progress-repetition">&ndash;&ndash;&ndash;</div>
      <div id="progress-bar">&ndash;&ndash;&ndash;</div>
      <div id="dots" class="dots"></div>
    </div>
    <div id="controls">
      <div id="buttons">
        <button id="start-stop">Start</button>
      </div>
      <fieldset id="fields">
        <div>
          <select id="tempo" title="Tempo in quarter notes per minute"></select>
          <label for="tempo">tempo</label>
        </div>
        <div>
          <input id="exercises" type="number" min="1" max="100" step="1" title="Number of exercises">
          <label for="exercises">exercises</label>
        </div>
        <div>
          <select id="repetitions" title="Number of repetitions per exercise">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="5">5</option>
            <option value="10">10</option>
            <option value="20">20</option>
            <option value="50">50</option>
          </select>
          <label for="repetitions">reps</label>
        </div>
        <div>
          <select id="bars" title="Number of bars per repetition"></select>
          <label for="bars">bars</label>
        </div>
        <div>
          <select id="beats" title="Beats (with subdivisions determines number of steps in pattern)"></select>
          <label for="beats">beats</label>
        </div>
        <div>
          <select id="subdivisions" title="Subdivisions (with beats determines number of steps in pattern)">
            <option value="1">&#9833;</option>
            <option value="2">&#9834;</option>
            <option value="4">&#119137;</option>
          </select>
          <label for="subdivisions">subs</label>
        </div>
        <div>
          <input id="pattern" type="text" title="Metronome pattern in REAPER-like format">
          <label for="pattern">pattern</label>
        </div>
        <div>
          <select id="preroll-bars" title="Number of preroll bars played before first exercise starts">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
          </select>
          <label for="preroll-bars">preroll</label>
        </div>
        <div id="preset-container">
          <select id="preset" title="Presets"></select>
          <label for="preset">presets</label>
        </div>
      </fieldset>
    </div>
  </div>
</body>

<script>
  //<![CDATA[
  "use strict";

  const START_CAPTION = "Start";
  const STOP_CAPTION = "Stop";

  const HIGH = "A";
  const MEDIUM = "B";
  const LOW = "C";
  const SILENT = "D";
  const HIGH_FREQUENCY = 880;
  const MEDIUM_FREQUENCY = 440;
  const LOW_FREQUENCY = 220;
  const BEEP_DURATION = 0.1;

  const DEFAULT_TEMPO = 120;
  const DEFAULT_EXERCISES = 24;
  const DEFAULT_REPETITIONS = 20;
  const DEFAULT_BARS = 2;
  const DEFAULT_BEATS = 4;
  const DEFAULT_SUBDIVISIONS = 2;
  const DEFAULT_PREROLL_BARS = 2;
  const DEFAULT_START_BAR = 0;

  const IDLE_HTML = "&ndash;&ndash;&ndash;";

  function h(s) {
    return new Option(s).innerHTML;
  }

  function attr(s) {
    return new Option(s).innerHTML.replace("\"", "&quot;");
  }

  function makeDefaultPattern(beats, subdivisions) {
    let pattern = "";
    for (let i = 0; i < beats; ++i) {
      if (i == 0) {
        pattern += HIGH;
      } else {
        pattern += MEDIUM;
      }

      for (let j = 0; j < subdivisions - 1; ++j) {
        pattern += LOW;
      }
    }

    console.assert(pattern.length == beats * subdivisions);
    return pattern;
  }

  function parsePattern(s, beats, subdivisions) {
    const len = beats * subdivisions;
    return s.substring(0, len).padEnd(len, "D");
  }

  function formatProgress(name, value, count, getReady = false) {
    return getReady ? `${name} ${value + 1} of ${count} (get ready!)` : `${name} ${value + 1} of ${count}`;
  }

  class Queue {
    #notes

    constructor() {
      this.#notes = [];
    }

    get isEmpty() { return this.#notes.length == 0; }

    enqueue(note) {
      this.#notes.push(note);
    }

    dequeue() {
      if (this.isEmpty) {
        return null;
      }

      return this.#notes.shift();
    }

    peek() {
      if (this.isEmpty) {
        return null;
      }
      return this.#notes[0];
    }

    clear() {
      this.#notes.length = 0;
    }
  }

  class Beeper {
    #audioCtx
    #tempo
    #beats
    #subdivisions
    #pattern
    #queue
    #interval
    #lookahead
    #stepInterval
    #nextStepTime
    #step
    #intervalId
    #currentBar

    constructor(options) {
      this.#audioCtx = options.audioCtx;
      this.#tempo = options.tempo;
      this.#beats = options.beats;
      this.#subdivisions = options.subdivisions;
      this.#pattern = options.pattern;
      this.#queue = options.queue;
      this.#interval = Object.hasOwn(options, "interval") ? options.interval : 30;
      this.#lookahead = Object.hasOwn(options, "lookahead") ? options.lookahead : 0.1;
      this.#stepInterval = 60 / this.#tempo / this.#subdivisions;
      this.#nextStepTime = null;
      this.#step = null;
      this.#intervalId = null;
      this.#currentBar = null;
    }

    start() {
      this.stop();
      this.#nextStepTime = this.#audioCtx.currentTime;
      this.#step = 0;
      this.#intervalId = setInterval(() => { this.#scheduleBeeps() }, this.#interval);
      this.#currentBar = 0;
    }

    stop() {
      if (this.#intervalId) {
        clearInterval(this.#intervalId);
        this.#intervalId = null;
      }
    }

    #scheduleBeeps() {
      while (this.#nextStepTime < this.#audioCtx.currentTime + this.#lookahead) {
        this.#scheduleBeep();
        this.#nextStepTime += this.#stepInterval;
        this.#step = (this.#step + 1) % this.#pattern.length;
        if (this.#step == 0) {
          ++this.#currentBar;
        }
      }
    }

    #scheduleBeep() {
      if (this.#step % this.#subdivisions == 0) {
        const beat = Math.trunc(this.#step / this.#subdivisions);
        this.#queue.enqueue({
          beat: beat,
          beats: this.#beats,
          time: this.#nextStepTime,
          currentBar: this.#currentBar
        });
      }

      const frequency = this.#stepFrequency();
      if (frequency) {
        const startTime = this.#nextStepTime;
        const endTime = startTime + BEEP_DURATION;

        const oscillator = this.#audioCtx.createOscillator();
        oscillator.type = "sawtooth";
        oscillator.frequency.value = frequency;
        oscillator.start(startTime);
        oscillator.stop(endTime);

        const gain = this.#audioCtx.createGain();
        gain.gain.setValueAtTime(1, startTime);
        gain.gain.exponentialRampToValueAtTime(0.1, endTime);

        oscillator.connect(gain);
        gain.connect(this.#audioCtx.destination);
      }
    }

    #stepFrequency() {
      switch (this.#pattern[this.#step]) {
        case HIGH: return HIGH_FREQUENCY;
        case MEDIUM: return MEDIUM_FREQUENCY;
        case LOW: return LOW_FREQUENCY;
        case HIGH: return null;
      }
    }
  }

  class Tracker {
    #id
    #audioCtx
    #queue
    #body
    #progressExerciseDiv
    #progressRepetitionDiv
    #progressBarDiv
    #dotsDiv
    #exercises
    #repetitions
    #bars
    #prerollBars
    #startExercise
    #onFinished
    #requestIds
    #beats
    #lastExercise

    constructor(options) {
      this.#id = options.id;
      this.#audioCtx = options.audioCtx;
      this.#queue = options.queue;
      this.#body = options.body;
      this.#progressExerciseDiv = options.progressExerciseDiv;
      this.#progressRepetitionDiv = options.progressRepetitionDiv;
      this.#progressBarDiv = options.progressBarDiv;
      this.#dotsDiv = options.dotsDiv;
      this.#exercises = options.exercises;
      this.#repetitions = options.repetitions;
      this.#bars = options.bars;
      this.#prerollBars = options.prerollBars;
      this.#startExercise = options.startExercise;
      this.#onFinished = options.onFinished;
      this.#requestIds = [];
      this.#beats = null;
      this.#lastExercise = 0;
    }

    get lastExercise() { return this.#lastExercise; }

    start() {
      this.#requestIds.push(window.requestAnimationFrame(() => this.#refresh()));
    }

    stop() {
      while (this.#requestIds.length > 0) {
        const requestId = this.#requestIds.pop();
        window.cancelAnimationFrame(requestId);
      }
    }

    #refresh() {
      const note = this.#nextNote();
      if (note) {
        if (!this.#update(note)) { return; }
      }
      this.#requestIds.push(window.requestAnimationFrame(() => this.#refresh()));
    }

    #nextNote() {
      const time = this.#audioCtx.currentTime;
      const note = this.#queue.peek();
      if (!note || note.time > time) { return null; }
      return this.#queue.dequeue();
    }

    #update(note) {
      if (note.beats != this.#beats) {
        this.#beats = note.beats;
        this.#dotsDiv.replaceChildren();
        for (let i = 0; i < this.#beats; ++i) {
          const e = document.createElement("div");
          e.innerHTML = (i + 1).toString();
          e.classList.add("dot");
          this.#dotsDiv.appendChild(e);
        }
      }

      [...this.#dotsDiv.children].forEach((e, i) => {
        if (i == note.beat) {
          e.classList.add("current");
        } else {
          e.classList.remove("current");
        }
      });

      let isLastBarOfRepetition;
      if (note.currentBar < this.#prerollBars) {
        isLastBarOfRepetition = note.currentBar == this.#prerollBars - 1;
        this.#progressExerciseDiv.innerHTML = `preroll &rarr; exercise ${this.#startExercise + 1}`;
        this.#progressRepetitionDiv.innerHTML = IDLE_HTML;
        this.#progressBarDiv.innerHTML = formatProgress("bar", note.currentBar, this.#prerollBars, isLastBarOfRepetition);
      } else {
        const [exercise, repetition, bar] = this.#position(note.currentBar - this.#prerollBars);
        isLastBarOfRepetition = repetition == this.#repetitions - 1 && bar == this.#bars - 1;
        const isFinished = exercise >= this.#exercises;
        this.#progressExerciseDiv.innerHTML = formatProgress("exercise", exercise, this.#exercises);
        this.#progressRepetitionDiv.innerHTML = formatProgress("rep", repetition, this.#repetitions);
        this.#progressBarDiv.innerHTML = formatProgress("bar", bar, this.#bars, isLastBarOfRepetition);
        this.#lastExercise = exercise;
        if (isFinished) {
          this.#onFinished();
          return false;
        }
      }

      if (isLastBarOfRepetition) {
        this.#body.classList.add("last");
      } else {
        this.#body.classList.remove("last");
      }

      return true;
    }

    #position(overallBar) {
      const barsInExercise = this.#bars * this.#repetitions;
      const exercise = Math.trunc(overallBar / barsInExercise) + this.#startExercise;
      const rem = overallBar % barsInExercise;
      const repetition = Math.trunc(rem / this.#bars);
      const bar = rem % this.#bars;
      return [exercise, repetition, bar];
    }
  }

  class App {
    #body
    #progressExerciseDiv
    #progressRepetitionDiv
    #progressBarDiv
    #dotsDiv
    #startStopBtn
    #fields
    #tempoSelect
    #exercisesInput
    #repetitionsSelect
    #barsSelect
    #beatsSelect
    #subdivisionsSelect
    #patternInput
    #prerollBarsSelect
    #trackerId
    #audioCtx
    #queue
    #startExercise
    #beeper
    #tracker

    constructor(document) {
      this.#body = document.body;
      this.#progressExerciseDiv = document.getElementById("progress-exercise");
      this.#progressRepetitionDiv = document.getElementById("progress-repetition");
      this.#progressBarDiv = document.getElementById("progress-bar");
      this.#dotsDiv = document.getElementById("dots");
      this.#startStopBtn = document.getElementById("start-stop");
      this.#fields = document.getElementById("fields");
      this.#tempoSelect = document.getElementById("tempo");
      this.#exercisesInput = document.getElementById("exercises");
      this.#repetitionsSelect = document.getElementById("repetitions");
      this.#barsSelect = document.getElementById("bars");
      this.#beatsSelect = document.getElementById("beats");
      this.#subdivisionsSelect = document.getElementById("subdivisions");
      this.#patternInput = document.getElementById("pattern");
      this.#prerollBarsSelect = document.getElementById("preroll-bars");

      this.#trackerId = 0;
      this.#audioCtx = new AudioContext();
      this.#queue = new Queue();
      this.#startExercise = 0;
      this.#beeper = null;
      this.#tracker = null;

      this.#initUi(document);
    }

    #initUi(document) {
      this.#progressExerciseDiv.innerHTML = IDLE_HTML;
      this.#progressRepetitionDiv.innerHTML = IDLE_HTML;
      this.#progressBarDiv.innerHTML = IDLE_HTML;
      this.#dotsDiv.replaceChildren();

      this.#populateSelect(document, this.#tempoSelect, 50, 250);
      this.#populateSelect(document, this.#barsSelect, 1, 4);
      this.#populateSelect(document, this.#beatsSelect, 1, 16);

      this.#startStopBtn.textContent = START_CAPTION;
      this.#tempoSelect.value = DEFAULT_TEMPO;
      this.#exercisesInput.value = DEFAULT_EXERCISES;
      this.#repetitionsSelect.value = DEFAULT_REPETITIONS;
      this.#barsSelect.value = DEFAULT_BARS;
      this.#beatsSelect.value = DEFAULT_BEATS;
      this.#subdivisionsSelect.value = DEFAULT_SUBDIVISIONS;
      this.#patternInput.value = makeDefaultPattern(DEFAULT_BEATS, DEFAULT_SUBDIVISIONS);
      this.#prerollBarsSelect.value = DEFAULT_PREROLL_BARS;

      const inputs = [
        this.#exercisesInput,
      ];
      for (const input of inputs) {
        input.addEventListener("keydown", e => {
          if (e.key == "e") {
            e.preventDefault();
          }
        })
      }

      this.#beatsSelect.addEventListener("input", e => {
        if (!e.target.validity.valid) { return; }
        const beats = e.target.valueAsNumber;
        if (Number.isNaN(beats)) { return; }

        if (!this.#subdivisionsSelect.validity.valid) { return; }
        const subdivisions = parseInt(this.#subdivisionsSelect.value);
        if (Number.isNaN(subdivisions)) { return; }

        this.#patternInput.value = makeDefaultPattern(beats, subdivisions);
      });

      this.#subdivisionsSelect.addEventListener("input", e => {
        if (!e.target.validity.valid) { return; }
        const subdivisions = parseInt(e.target.value);
        if (Number.isNaN(subdivisions)) { return; }

        if (!this.#beatsSelect.validity.valid) { return; }
        const beats = this.#beatsSelect.valueAsNumber;
        if (Number.isNaN(beats)) { return; }

        this.#patternInput.value = makeDefaultPattern(beats, subdivisions);
      });

      this.#startStopBtn.addEventListener("click", e => {
        if (e.target.textContent == START_CAPTION) {
          this.#startMetronome();
        }
        else if (e.target.textContent == STOP_CAPTION) {
          this.#stopMetronome();
        }
      });

      document.addEventListener("keydown", e => {
        if (e.key == " ") {
          if (this.#startStopBtn != document.activeElement) {
            this.#startStopBtn.click();
          }
        }
      });
    }

    #populateSelect(document, select, min, max) {
      select.replaceChildren();
      for (let i = min; i <= max; ++i) {
        const e = document.createElement("option");
        e.value = i;
        e.innerHTML = i.toString();
        select.appendChild(e);
      }
    }


    #startMetronome() {
      console.assert(!this.#tracker && !this.#beeper);

      this.#startStopBtn.textContent = STOP_CAPTION;
      this.#fields.disabled = true;

      const tempo = parseInt(this.#tempoSelect.value);
      const exercises = this.#exercisesInput.valueAsNumber;
      const repetitions = parseInt(this.#repetitionsSelect.value);
      const bars = parseInt(this.#barsSelect.value);
      const beats = parseInt(this.#beatsSelect.value);
      const subdivisions = parseInt(this.#subdivisionsSelect.value);
      const pattern = parsePattern(this.#patternInput.value, beats, subdivisions);
      const prerollBars = parseInt(this.#prerollBarsSelect.value);

      this.#beeper = new Beeper({
        audioCtx: this.#audioCtx,
        tempo: tempo,
        beats: beats,
        subdivisions: subdivisions,
        pattern: pattern,
        queue: this.#queue
      });

      this.#tracker = new Tracker({
        id: ++this.#trackerId,
        audioCtx: this.#audioCtx,
        queue: this.#queue,
        body: this.#body,
        progressExerciseDiv: this.#progressExerciseDiv,
        progressRepetitionDiv: this.#progressRepetitionDiv,
        progressBarDiv: this.#progressBarDiv,
        dotsDiv: this.#dotsDiv,
        exercises: exercises,
        repetitions: repetitions,
        bars: bars,
        prerollBars: prerollBars,
        startExercise: this.#startExercise,
        onFinished: () => this.#setMetronomeIdle()
      });

      this.#startExercise = 0;

      this.#tracker.start();
      this.#beeper.start();
    }

    #stopMetronome() {
      console.assert(this.#tracker && this.#beeper);

      if (this.#startStopBtn.textContent == STOP_CAPTION &&
        this.#tracker.lastExercise &&
        !confirm("Discard current progress? (OK to stop, Esc to restart current exercise with preroll)")) {
        const lastExercise = this.#tracker.lastExercise;
        this.#setMetronomeIdle();
        this.#startExercise = lastExercise;
        this.#startMetronome();
        return;
      }
      else {
        this.#setMetronomeIdle();
      }
    }

    #setMetronomeIdle() {
      if (this.#beeper) {
        this.#beeper.stop();
        this.#beeper = null;
      }

      if (this.#tracker) {
        this.#tracker.stop();
        this.#tracker = null;
      }

      this.#queue.clear();

      this.#body.classList.remove("last");
      this.#progressExerciseDiv.innerHTML = IDLE_HTML;
      this.#progressRepetitionDiv.innerHTML = IDLE_HTML;
      this.#progressBarDiv.innerHTML = IDLE_HTML;
      this.#dotsDiv.replaceChildren();

      this.#startStopBtn.textContent = START_CAPTION;
      this.#fields.disabled = false;

      this.#startExercise = 0;
    }
  }

  (() => {
    function populatePresets(data) {
      if (Object.hasOwn(data, "presets")) {
        const repetitionsSelect = document.getElementById("repetitions");
        const presetContainerDiv = document.getElementById("preset-container");
        const presetSelect = document.getElementById("preset");

        for (const preset of data.presets) {
          const e = document.createElement("option");
          e.innerHTML = h(preset.name);
          e.dataset.presetJson = JSON.stringify(preset);
          presetSelect.appendChild(e);
        }

        presetContainerDiv.style.setProperty("display", "inline-block", "important");
        presetSelect.selectedIndex = -1;
        presetSelect.addEventListener("change", e => {
          const preset = JSON.parse(e.target.options[e.target.selectedIndex].dataset.presetJson);
          if (Object.hasOwn(preset, "repetitions")) {
            repetitionsSelect.value = preset.repetitions;
          }
        })
      }
    }

    fetch("datax.json").then(response => {
      if (response.ok) {
        return response.json();
      } else {
        throw new Error(`Failed to retrieve data from ${response.url}`);
      }
    }).then(populatePresets).catch(console.error).then(() => new App(document));
  })();
  //]]>
</script>

</html>
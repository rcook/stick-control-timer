<!DOCTYPE html>
<html lang="en">

<head>
  <title>Stick Control Metronome</title>
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: Verdana, Geneva, Tahoma, sans-serif;
      margin: 0px;
      display: flex;
      height: 100vh;
      align-items: center;
      background-color: limegreen;
    }

    body.last {
      animation: blink 0.75s linear infinite;
    }

    @keyframes blink {
      0% {
        background-color: white;
      }

      50% {
        background-color: red;
      }

      100% {
        background-color: white;
      }
    }

    #container {
      width: fit-content;
      margin: 0 auto;
    }

    .dots {
      display: flex;
      min-width: 900px;
      height: 200px;
    }

    .dot {
      width: 125px;
      height: 125px;
      border-radius: 50%;
      border: 5px solid green;
      display: grid;
      align-items: center;
      text-align: center;
      font-size: 2em;
      margin: 20px;
      color: lime;
    }

    .current {
      background-color: lightgreen;
      color: darkgreen;
    }

    #progress-repetitions,
    #progress-bars {
      font-size: 5em;
    }

    #controls {
      display: flex;
    }

    #fields {
      display: inline;
      border: none;
    }

    #fields div {
      display: inline-block;
    }

    #fields label {
      display: block;
    }

    #fields input,
    #fields select {
      box-sizing: border-box;
      vertical-align: top;
      height: 32px;
      padding: 5px;
    }

    #buttons {
      align-content: center;
    }

    #buttons button {
      height: 32px;
    }

    #progress-exercise {
      font-size: 3em;
    }

    #progress-repetition,
    #progress-bar {
      font-size: 2em;
    }

    #preset-container {
      display: none !important;
    }

    .popup-source .label {
      color: lightgreen;
    }

    .popup-source:hover {
      text-decoration: underline;
    }

    .popup-source:hover .popup {
      visibility: visible;
      filter: drop-shadow(8px 8px 10px grey);
    }

    .popup {
      border-radius: 10px;
      visibility: hidden;
      position: absolute;
      z-index: 1;
      background-color: whitesmoke;
      padding: 10px;
      border: 1px solid black;
      max-width: 40vw;
      height: 50vh;
      overflow-y: scroll;
    }

    .popup th,
    .popup td {
      text-align: left;
      padding: 2px 5px 2px 5px;
    }

    .fetch-error {
      color: darkred;
      background: #ffe0e0;
      padding: 0.5rem 1rem;
      margin: 0.5rem 0;
      border-radius: 4px;
    }
  </style>
</head>

<body>
  <div id="container">
    <div class="popup-source">
      <a class="label">(?)</a>
      <div class="popup">
        <p>
          This is a simple metronome and timer app I wrote to help me work through <a
            href="https://www.stonepercussionbooks.com/stick-control.html">Stick Control</a> by George Stone.
        </p>
        <p>
          Note that the exercises in the book are notated in cut time (2/2). Since I want to use this tool for other
          practice exercises, I have chosen to measure bars in terms of quarter notes instead of half-notes which is a
          little more convenient for practising along to music in 3/4, for example. Similarly,
          tempo is defined here in terms of quarter notes per minute.
        </p>
        <p>
          &ldquo;Preroll&rdquo; refers to one or more pickup bars that run immediately before the first exercise in
          order for the user to gauge the correct tempo to play at. The page will flash an angry red colour when you hit
          the last bar of the last repetition of each exercise in order to alert you that the next exercise is coming
          up.
        </p>
        <p>
          <a href="https://github.com/rcook/stick-control-metronome">Source code on GitHub</a>
        </p>
        <p>
          Written by <a href="https://blog.rcook.org/">Richard Cook</a>
        </p>
        <h3>Patterns</h3>
        <p>
          The <em>pattern</em> field defines the pattern of accents of the metronome clicks. This will be a string whose
          length is <em>beats &times; subdivisions</em> where each character represents the click type to generate at
          the corresponding step:
        </p>
        <table>
          <thead>
            <tr>
              <th>Character</th>
              <th>Sound</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>A</td>
              <td>Strong accent</td>
            </tr>
            <tr>
              <td>B</td>
              <td>Weak accent</td>
            </tr>
            <tr>
              <td>C</td>
              <td>No accent</td>
            </tr>
            <tr>
              <td>D</td>
              <td>Silent (no click)</td>
            </tr>
          </tbody>
        </table>
        <p>
          The pattern will be truncated and padded to the correct number of steps and any unsupported characters will be
          ignored and replaced with silence.
        </p>
        <h3>Keyboard</h3>
        <p>
          <em>Space</em> can be pressed to start and stop the metronome. If you stop the metronome beyond the first
          exercise, you will be presented with a prompt allowing you to stop or resume the metronome and timer from the
          beginning of the current exercise with a fresh run of preroll bars&mdash;this is useful when your practice
          routine is interrupted by a phone call or a dog in desperate need of a belly rub.
        </p>
      </div>
    </div>
    <div id="indicators">
      <div id="progress-exercise">&ndash;&ndash;&ndash;</div>
      <div id="progress-repetition">&ndash;&ndash;&ndash;</div>
      <div id="progress-bar">&ndash;&ndash;&ndash;</div>
      <div id="dots" class="dots"></div>
    </div>
    <div id="fetch-error" class="fetch-error" role="alert" hidden></div>
    <div id="controls">
      <div id="buttons">
        <button id="start-stop">Start</button>
      </div>
      <fieldset id="fields">
        <div>
          &#9833;=<select id="tempo" title="Tempo in quarter notes per minute"></select>
          <label for="tempo">tempo</label>
        </div>
        <div>
          <input id="start-exercise" type="number" min="1" max="100" step="1" title="Start exercise">
          <label for="start-exercise">start</label>
        </div>
        <div>
          <input id="exercises" type="number" min="1" max="100" step="1" title="Number of exercises">
          <label for="exercises">exercises</label>
        </div>
        <div>
          <select id="repetitions" title="Number of repetitions per exercise">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="5">5</option>
            <option value="10">10</option>
            <option value="20">20</option>
            <option value="50">50</option>
          </select>
          <label for="repetitions">reps</label>
        </div>
        <div>
          <select id="bars" title="Number of bars per repetition"></select>
          <label for="bars">bars</label>
        </div>
        <div>
          <select id="beats" title="Beats (with subdivisions determines number of steps in pattern)"></select>
          <label for="beats">beats</label>
        </div>
        <div>
          <select id="subdivisions" title="Subdivisions (with beats determines number of steps in pattern)">
            <option value="1">(None)</option>
            <option value="2">8th note</option>
            <option value="4">16th note</option>
          </select>
          <label for="subdivisions">subs</label>
        </div>
        <div>
          <input id="pattern" type="text" title="Metronome pattern in REAPER-like format">
          <label for="pattern">pattern</label>
        </div>
        <div>
          <select id="preroll-bars" title="Number of preroll bars played before first exercise starts">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
          </select>
          <label for="preroll-bars">preroll</label>
        </div>
        <div id="preset-container">
          <select id="preset" title="Presets"></select>
          <label for="preset">presets</label>
        </div>
      </fieldset>
    </div>
  </div>
</body>

<script>
  //<![CDATA[
  "use strict";

  const DATA_FILE_NAME = "data.json";

  const SAVE_ID = -1;
  const REMOVE_ID = -2;
  const CLEAR_ID = -3;
  const EXPORT_ID = -4;
  const RESET_ID = -5;

  const START_CAPTION = "Start";
  const STOP_CAPTION = "Stop";

  const Accent = Object.freeze({
    HIGH: "A",
    MEDIUM: "B",
    LOW: "C",
    SILENT: "D"
  });

  const BEEP_DURATION = 0.05;

  const DEFAULT_TEMPO = 120;
  const DEFAULT_START_EXERCISE = 1;
  const DEFAULT_EXERCISES = 24;
  const DEFAULT_REPETITIONS = 20;
  const DEFAULT_BARS = 2;
  const DEFAULT_BEATS = 4;
  const DEFAULT_SUBDIVISIONS = 2;
  const DEFAULT_PREROLL_BARS = 2;
  const DEFAULT_START_BAR = 0;

  const IDLE_HTML = "&ndash;&ndash;&ndash;";

  const OSCILLATOR_PADDING = 0.01;

  const SILENT_PARAM = "silent";
  const IMPORT_PRESETS_PARAM = "import-presets";

  function h(s) {
    return new Option(s).innerHTML;
  }

  function attr(s) {
    return new Option(s).innerHTML.replaceAll("\"", "&quot;");
  }

  function makeDefaultPattern(beats, subdivisions) {
    let pattern = "";
    for (let i = 0; i < beats; ++i) {
      if (i === 0) {
        pattern += Accent.HIGH;
      } else {
        pattern += Accent.MEDIUM;
      }

      for (let j = 0; j < subdivisions - 1; ++j) {
        pattern += Accent.LOW;
      }
    }

    console.assert(pattern.length === beats * subdivisions);
    return pattern;
  }

  function parsePattern(s, beats, subdivisions) {
    const len = beats * subdivisions;
    return s.substring(0, len).padEnd(len, "D");
  }

  function formatProgress(name, value, count, offset = null, getReady = false) {
    let s = offset === null ? `${name} ${value + 1} of ${count}` : `${name} ${value + offset + 1} (${value + 1} of ${count})`;
    if (getReady) {
      s += " (get ready!)";
    }
    return s;
  }

  class DecayingSawtoothClick {
    #frequency
    #volume

    static Builder(frequency, volume) {
      return new class {
        constructor() { }

        build(audioCtx) {
          return new DecayingSawtoothClick(frequency, volume);
        }
      }
    }

    constructor(frequency, volume) {
      this.#frequency = frequency;
      this.#volume = volume;
    }

    generate(audioCtx, startTime) {
      const endTime = startTime + BEEP_DURATION;

      const oscillator = audioCtx.createOscillator();
      oscillator.type = "sawtooth";
      oscillator.frequency.setValueAtTime(this.#frequency, startTime);
      oscillator.start(startTime);
      oscillator.stop(endTime + OSCILLATOR_PADDING);

      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(this.#volume, startTime);
      gain.gain.exponentialRampToValueAtTime(0.0001, endTime);

      oscillator.connect(gain).connect(audioCtx.destination);
    }
  }

  class FilteredWhiteNoiseClick {
    static #buffers = {};
    #buffer

    static Builder() {
      return new class {
        constructor() { }

        build(audioCtx) {
          const buffer = FilteredWhiteNoiseClick.#getBuffer(audioCtx);
          return new FilteredWhiteNoiseClick(buffer);
        }
      }
    }

    constructor(buffer) {
      this.#buffer = buffer;
    }

    generate(audioCtx, startTime) {
      const endTime = startTime + BEEP_DURATION;

      const noise = audioCtx.createBufferSource();
      noise.buffer = this.#buffer;
      noise.start(startTime);
      noise.stop(endTime);

      const filter = audioCtx.createBiquadFilter();
      filter.type = "highpass";
      filter.frequency.setValueAtTime(2000, audioCtx.currentTime);

      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0, startTime);
      gain.gain.linearRampToValueAtTime(1, startTime + 0.001);
      gain.gain.exponentialRampToValueAtTime(0.001, endTime);

      noise.connect(filter).connect(gain).connect(audioCtx.destination);
    }

    static #getBuffer(audioCtx) {
      const temp = FilteredWhiteNoiseClick.#buffers[audioCtx];
      if (temp !== undefined) { return temp; }

      const bufferLen = audioCtx.sampleRate * 0.5;
      const buffer = audioCtx.createBuffer(1, bufferLen, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferLen; ++i) {
        data[i] = Math.random() * 2 - 1;
      }

      FilteredWhiteNoiseClick.#buffers[audioCtx] = buffer;
      return buffer
    }
  }

  class Queue {
    #notes = [];

    constructor() { }

    get isEmpty() { return this.#notes.length === 0; }

    enqueue(note) {
      this.#notes.push(note);
    }

    dequeue() {
      if (this.isEmpty) {
        return null;
      }

      return this.#notes.shift();
    }

    peek() {
      if (this.isEmpty) {
        return null;
      }
      return this.#notes[0];
    }

    clear() {
      this.#notes.length = 0;
    }
  }

  class Beeper {
    #audioCtx
    #tempo
    #beats
    #subdivisions
    #pattern
    #queue
    #interval
    #lookahead
    #stepInterval
    #nextStepTime = null;
    #step = null;
    #intervalId = null;
    #currentBar = null;
    #clicks

    constructor(options) {
      this.#audioCtx = options.audioCtx;
      this.#tempo = options.tempo;
      this.#beats = options.beats;
      this.#subdivisions = options.subdivisions;
      this.#pattern = options.pattern;
      this.#queue = options.queue;
      this.#interval = Object.hasOwn(options, "interval") ? options.interval : 30;
      this.#lookahead = Object.hasOwn(options, "lookahead") ? options.lookahead : 0.1;
      this.#stepInterval = 60 / this.#tempo / this.#subdivisions;
      this.#clicks = Object.keys(options.clicks).reduce((acc, k) => {
        const factory = options.clicks[k];
        const click = factory ? factory.build(this.#audioCtx) : null;
        acc[k] = click;
        return acc;
      }, {});
    }

    start() {
      this.stop();
      this.#nextStepTime = this.#audioCtx.currentTime;
      this.#step = 0;
      this.#intervalId = setInterval(() => { this.#scheduleBeeps() }, this.#interval);
      this.#currentBar = 0;
    }

    stop() {
      if (this.#intervalId) {
        clearInterval(this.#intervalId);
        this.#intervalId = null;
      }
    }

    #scheduleBeeps() {
      while (this.#nextStepTime < this.#audioCtx.currentTime + this.#lookahead) {
        this.#scheduleBeep();
        this.#nextStepTime += this.#stepInterval;
        this.#step = (this.#step + 1) % this.#pattern.length;
        if (this.#step === 0) {
          ++this.#currentBar;
        }
      }
    }

    #scheduleBeep() {
      if (this.#step % this.#subdivisions === 0) {
        const beat = Math.trunc(this.#step / this.#subdivisions);
        this.#queue.enqueue({
          beat: beat,
          beats: this.#beats,
          time: this.#nextStepTime,
          currentBar: this.#currentBar
        });
      }

      const click = this.#clicks[this.#pattern[this.#step]];
      if (click) {
        click.generate(this.#audioCtx, this.#nextStepTime)
      }
    }
  }

  class Tracker {
    #id
    #audioCtx
    #queue
    #body
    #progressExerciseDiv
    #progressRepetitionDiv
    #progressBarDiv
    #dotsDiv
    #exerciseOffset
    #exercises
    #repetitions
    #bars
    #prerollBars
    #startExercise
    #onFinished
    #requestIds = [];
    #beats = null;
    #lastExercise = 0;

    constructor(options) {
      this.#id = options.id;
      this.#audioCtx = options.audioCtx;
      this.#queue = options.queue;
      this.#body = options.body;
      this.#progressExerciseDiv = options.progressExerciseDiv;
      this.#progressRepetitionDiv = options.progressRepetitionDiv;
      this.#progressBarDiv = options.progressBarDiv;
      this.#dotsDiv = options.dotsDiv;
      this.#exerciseOffset = options.exerciseOffset;
      this.#exercises = options.exercises;
      this.#repetitions = options.repetitions;
      this.#bars = options.bars;
      this.#prerollBars = options.prerollBars;
      this.#startExercise = options.startExercise;
      this.#onFinished = options.onFinished;
    }

    get lastExercise() { return this.#lastExercise; }

    start() {
      this.#requestIds.push(window.requestAnimationFrame(() => this.#refresh()));
    }

    stop() {
      while (this.#requestIds.length > 0) {
        const requestId = this.#requestIds.pop();
        window.cancelAnimationFrame(requestId);
      }
    }

    #refresh() {
      const note = this.#nextNote();
      if (note) {
        if (!this.#update(note)) { return; }
      }
      this.#requestIds.push(window.requestAnimationFrame(() => this.#refresh()));
    }

    #nextNote() {
      const time = this.#audioCtx.currentTime;
      const note = this.#queue.peek();
      if (!note || note.time > time) { return null; }
      return this.#queue.dequeue();
    }

    #update(note) {
      if (note.beats !== this.#beats) {
        this.#beats = note.beats;
        this.#dotsDiv.replaceChildren();
        for (let i = 0; i < this.#beats; ++i) {
          const e = document.createElement("div");
          e.innerHTML = (i + 1).toString();
          e.classList.add("dot");
          this.#dotsDiv.appendChild(e);
        }
      }

      [...this.#dotsDiv.children].forEach((e, i) => {
        if (i === note.beat) {
          e.classList.add("current");
        } else {
          e.classList.remove("current");
        }
      });

      let isLastBarOfRepetition;
      if (note.currentBar < this.#prerollBars) {
        isLastBarOfRepetition = note.currentBar === this.#prerollBars - 1;
        this.#progressExerciseDiv.innerHTML = `preroll &rarr; exercise ${this.#startExercise + this.#exerciseOffset + 1}`;
        this.#progressRepetitionDiv.innerHTML = IDLE_HTML;
        this.#progressBarDiv.innerHTML = formatProgress("bar", note.currentBar, this.#prerollBars, null, isLastBarOfRepetition);
      } else {
        const [exercise, repetition, bar] = this.#position(note.currentBar - this.#prerollBars);
        isLastBarOfRepetition = repetition === this.#repetitions - 1 && bar === this.#bars - 1;
        const isFinished = exercise >= this.#exercises;
        this.#progressExerciseDiv.innerHTML = formatProgress("exercise", exercise, this.#exercises, this.#exerciseOffset);
        this.#progressRepetitionDiv.innerHTML = formatProgress("rep", repetition, this.#repetitions);
        this.#progressBarDiv.innerHTML = formatProgress("bar", bar, this.#bars, null, isLastBarOfRepetition);
        this.#lastExercise = exercise;
        if (isFinished) {
          this.#onFinished();
          return false;
        }
      }

      if (isLastBarOfRepetition) {
        this.#body.classList.add("last");
      } else {
        this.#body.classList.remove("last");
      }

      return true;
    }

    #position(overallBar) {
      const barsInExercise = this.#bars * this.#repetitions;
      const exercise = Math.trunc(overallBar / barsInExercise) + this.#startExercise;
      const rem = overallBar % barsInExercise;
      const repetition = Math.trunc(rem / this.#bars);
      const bar = rem % this.#bars;
      return [exercise, repetition, bar];
    }
  }

  class App {
    #body
    #progressExerciseDiv
    #progressRepetitionDiv
    #progressBarDiv
    #dotsDiv
    #startStopBtn
    #fields
    #tempoSelect
    #startExerciseInput
    #exercisesInput
    #repetitionsSelect
    #barsSelect
    #beatsSelect
    #subdivisionsSelect
    #patternInput
    #prerollBarsSelect
    #presetContainerDiv
    #presetSelect
    #fetchErrorDiv
    #trackerId = 0;
    #audioCtx = new AudioContext();
    #queue = new Queue();
    #startExercise = 0;
    #beeper = null;
    #tracker = null;
    #paramElements
    #paramMetadata
    #clicks

    constructor(document, window) {
      const params = new URLSearchParams(window.location.search);
      const silent = params.get(SILENT_PARAM) === "1";
      const importPresets = params.get(IMPORT_PRESETS_PARAM);

      this.#body = document.body;
      this.#progressExerciseDiv = document.getElementById("progress-exercise");
      this.#progressRepetitionDiv = document.getElementById("progress-repetition");
      this.#progressBarDiv = document.getElementById("progress-bar");
      this.#dotsDiv = document.getElementById("dots");
      this.#startStopBtn = document.getElementById("start-stop");
      this.#fields = document.getElementById("fields");
      this.#tempoSelect = document.getElementById("tempo");
      this.#startExerciseInput = document.getElementById("start-exercise");
      this.#exercisesInput = document.getElementById("exercises");
      this.#repetitionsSelect = document.getElementById("repetitions");
      this.#barsSelect = document.getElementById("bars");
      this.#beatsSelect = document.getElementById("beats");
      this.#subdivisionsSelect = document.getElementById("subdivisions");
      this.#patternInput = document.getElementById("pattern");
      this.#prerollBarsSelect = document.getElementById("preroll-bars");
      this.#presetContainerDiv = document.getElementById("preset-container");
      this.#presetSelect = document.getElementById("preset");
      this.#fetchErrorDiv = document.getElementById("fetch-error");

      this.#paramElements = [
        this.#tempoSelect,
        this.#startExerciseInput,
        this.#exercisesInput,
        this.#repetitionsSelect,
        this.#barsSelect,
        this.#beatsSelect,
        this.#subdivisionsSelect,
        this.#patternInput,
        this.#prerollBarsSelect
      ].toSorted((a, b) => a.id.localeCompare(b.id));
      this.#paramMetadata = {
        [this.#tempoSelect.id]: { name: "tempo", default: DEFAULT_TEMPO },
        [this.#startExerciseInput.id]: { name: "startExercise", default: DEFAULT_START_EXERCISE },
        [this.#exercisesInput.id]: { name: "exercises", default: DEFAULT_EXERCISES },
        [this.#repetitionsSelect.id]: { name: "repetitions", default: DEFAULT_REPETITIONS },
        [this.#barsSelect.id]: { name: "bars", default: DEFAULT_BARS },
        [this.#beatsSelect.id]: { name: "beats", default: DEFAULT_BEATS },
        [this.#subdivisionsSelect.id]: { name: "subdivisions", default: DEFAULT_SUBDIVISIONS },
        [this.#patternInput.id]: { name: "pattern", default: makeDefaultPattern(DEFAULT_BEATS, DEFAULT_SUBDIVISIONS) },
        [this.#prerollBarsSelect.id]: { name: "prerollBars", default: DEFAULT_PREROLL_BARS }
      };

      const volume = silent ? 0.0 : 1.0;
      this.#clicks = {
        [Accent.HIGH]: DecayingSawtoothClick.Builder(1760, volume),
        [Accent.MEDIUM]: DecayingSawtoothClick.Builder(880, volume),
        [Accent.LOW]: DecayingSawtoothClick.Builder(440, volume),
        [Accent.SILENT]: null
      };

      this.#initUi(document);

      if (importPresets !== null) {
        const s = atob(importPresets);
        const presets = JSON.parse(s);
        if (confirm(`Import ${presets.length} presets from URL?`)) {
          this.#writePresets(presets);
        }
        this.#pushState();
      }

      if (this.#readPresets() === null) {
        this.#fetchPresets()
          .then(() => this.#initPresetsUi())
          .catch(e => {
            this.#showFetchError(e);
            this.#initPresetsUi();
          });
      } else {
        this.#initPresetsUi();
      }
    }

    #showFetchError(e) {
      this.#fetchErrorDiv.textContent = e.message || "(unknown error)";
      this.#fetchErrorDiv.hidden = false;
    }

    #hideFetchError() {
      this.#fetchErrorDiv.hidden = true;
      this.#fetchErrorDiv.textContent = "";
    }

    #fetchPresets() {
      return fetch(DATA_FILE_NAME, { cache: "no-store" }).then(response => {
        if (response.ok && false) {
          return response.json();
        } else {
          console.error(`Fetch from ${response.url} failed with HTTP status ${response.status}`);
          throw new Error(`Failed to load default presets from ${DATA_FILE_NAME}`);
        }
      }).then(data => this.#writePresets(Object.hasOwn(data, "presets") ? data.presets : []));
    }

    #readPresets() {
      const json = localStorage.getItem("presets");
      return json === null ? null : JSON.parse(json).toSorted((a, b) => a.name.localeCompare(b.name));
    }

    #writePresets(presets) {
      const sortedPresets = presets.toSorted((a, b) => a.name.localeCompare(b.name));
      const json = JSON.stringify(sortedPresets);
      localStorage.setItem("presets", json);
      return sortedPresets;
    }

    #addOrOverwritePreset(preset) {
      const presets = this.#readPresets().filter(p => p.name.localeCompare(preset.name));
      presets.push(preset);
      const newPresets = this.#writePresets(presets);
      return newPresets.findIndex(p => !p.name.localeCompare(preset.name));
    }

    #initUi(document) {
      this.#progressExerciseDiv.innerHTML = IDLE_HTML;
      this.#progressRepetitionDiv.innerHTML = IDLE_HTML;
      this.#progressBarDiv.innerHTML = IDLE_HTML;
      this.#dotsDiv.replaceChildren();

      this.#populateSelect(document, this.#tempoSelect, 50, 250);
      this.#populateSelect(document, this.#barsSelect, 1, 4);
      this.#populateSelect(document, this.#beatsSelect, 1, 16);

      this.#startStopBtn.textContent = START_CAPTION;

      const params = new URLSearchParams(window.location.search);
      for (const e of this.#paramElements) {
        const value = params.get(e.id);
        e.value = value === null ? this.#paramMetadata[e.id].default : value;
      }

      const inputs = [
        this.#startExerciseInput,
        this.#exercisesInput,
      ];
      for (const input of inputs) {
        input.addEventListener("keydown", e => {
          if (e.key === "e") {
            e.preventDefault();
          }
        })
      }

      for (const e of this.#paramElements) {
        e.addEventListener("input", e => {
          this.#presetSelect.selectedIndex = -1;
          this.#pushState();
        });
      }

      this.#beatsSelect.addEventListener("input", e => {
        if (!e.target.validity.valid) { return; }
        const beats = parseInt(e.target.value);
        if (Number.isNaN(beats)) { return; }

        if (!this.#subdivisionsSelect.validity.valid) { return; }
        const subdivisions = parseInt(this.#subdivisionsSelect.value);
        if (Number.isNaN(subdivisions)) { return; }

        this.#patternInput.value = makeDefaultPattern(beats, subdivisions);
      });

      this.#subdivisionsSelect.addEventListener("input", e => {
        if (!e.target.validity.valid) { return; }
        const subdivisions = parseInt(e.target.value);
        if (Number.isNaN(subdivisions)) { return; }

        if (!this.#beatsSelect.validity.valid) { return; }
        const beats = parseInt(this.#beatsSelect.value);
        if (Number.isNaN(beats)) { return; }

        this.#patternInput.value = makeDefaultPattern(beats, subdivisions);
      });

      this.#startStopBtn.addEventListener("click", e => {
        if (e.target.textContent === START_CAPTION) {
          this.#startMetronome();
        }
        else if (e.target.textContent === STOP_CAPTION) {
          this.#stopMetronome();
        }
      });

      document.addEventListener("keydown", e => {
        if (e.key === " ") {
          if (this.#startStopBtn !== document.activeElement) {
            this.#startStopBtn.click();
          }
        }
      });
    }

    #initPresetsUi() {
      this.#populatePresetsUi();

      this.#presetSelect.addEventListener("change", e => {
        if (e.target.value.length > 0) {
          const command = parseInt(e.target.value);
          e.target.selectedIndex = -1;
          switch (command) {
            case SAVE_ID: {
              const name = prompt("Enter preset name");
              if (name !== null) {
                const idx = this.#addOrOverwritePreset({
                  name: name,
                  tempo: parseInt(this.#tempoSelect.value),
                  startExercise: this.#startExerciseInput.valueAsNumber,
                  exercises: this.#exercisesInput.valueAsNumber,
                  repetitions: parseInt(this.#repetitionsSelect.value),
                  bars: parseInt(this.#barsSelect.value),
                  beats: parseInt(this.#beatsSelect.value),
                  subdivisions: parseInt(this.#subdivisionsSelect.value),
                  pattern: this.#patternInput.value,
                  prerollBars: parseInt(this.#prerollBarsSelect.value)
                });
                this.#populatePresetsUi();
                this.#presetSelect.selectedIndex = idx;
              }
              break;
            }
            case REMOVE_ID: {
              const name = prompt("Enter preset name");
              if (name !== null) {
                this.#writePresets(this.#readPresets().filter(p => p.name.localeCompare(name)));
                this.#populatePresetsUi();
              }
              break;
            }
            case CLEAR_ID: {
              this.#writePresets([]);
              this.#populatePresetsUi();
              break;
            }
            case EXPORT_ID: {
              const s = JSON.stringify(this.#readPresets());
              const encoded = btoa(s);
              const url = new URL(window.location.href);
              url.searchParams.forEach((v, k) => url.searchParams.delete(k));
              url.searchParams.set(IMPORT_PRESETS_PARAM, encoded);
              prompt("Copy this link and paste into a different browser to import your presets", url.toString());
              break;
            }
            case RESET_ID: {
              this
                .#fetchPresets()
                .then(() => this.#populatePresetsUi())
                .catch(e => this.#showFetchError(e));
              break;
            }
          }
          return;
        }

        const selectedOption = e.target.options[e.target.selectedIndex];
        const preset = JSON.parse(selectedOption.dataset.presetJson);
        for (const e of this.#paramElements) {
          const m = this.#paramMetadata[e.id];
          if (Object.hasOwn(preset, m.name)) {
            e.value = preset[m.name];
          }
        }
        this.#pushState();
      })
    }

    #populatePresetsUi() {
      function addCommandOption(presetSelect, innerHtml, value = null, disabled = false) {
        const e = document.createElement("option");
        e.innerHTML = innerHtml;
        if (value) {
          e.value = value;
        }
        e.disabled = disabled;
        presetSelect.appendChild(e);
      }

      this.#presetSelect.replaceChildren();

      const presets = this.#readPresets();
      if (presets.length > 0) {
        for (const preset of this.#readPresets()) {
          const e = document.createElement("option");
          e.innerHTML = h(preset.name);
          e.value = "";
          e.dataset.presetJson = JSON.stringify(preset);
          this.#presetSelect.appendChild(e);
        }

        addCommandOption(this.#presetSelect, "__________", null, true);
      }

      addCommandOption(this.#presetSelect, "Save current parameters as preset...", SAVE_ID);
      addCommandOption(this.#presetSelect, "Remove preset...", REMOVE_ID);
      addCommandOption(this.#presetSelect, "Clear all presets", CLEAR_ID);
      addCommandOption(this.#presetSelect, "Export presets...", EXPORT_ID);
      addCommandOption(this.#presetSelect, "Reset presets to defaults", RESET_ID);

      this.#presetContainerDiv.style.setProperty("display", "inline-block", "important");
      this.#presetSelect.selectedIndex = -1;
    }

    #pushState() {
      const url = new URL(window.location.href);
      url.searchParams.forEach((v, k) => url.searchParams.delete(k));
      for (const e of this.#paramElements) {
        url.searchParams.set(e.id, e.value);
      }
      window.history.replaceState({}, "", url);
    }

    #populateSelect(document, select, min, max, htmlFunc = null) {
      select.replaceChildren();
      for (let i = min; i <= max; ++i) {
        const e = document.createElement("option");
        e.value = i;
        e.innerHTML = htmlFunc ? htmlFunc(i) : i.toString();
        select.appendChild(e);
      }
    }

    #startMetronome() {
      console.assert(!this.#tracker && !this.#beeper);
      this.#hideFetchError();

      this.#startStopBtn.textContent = STOP_CAPTION;
      this.#fields.disabled = true;

      const tempo = parseInt(this.#tempoSelect.value);
      const exerciseOffset = this.#startExerciseInput.valueAsNumber - 1;
      const exercises = this.#exercisesInput.valueAsNumber;
      const repetitions = parseInt(this.#repetitionsSelect.value);
      const bars = parseInt(this.#barsSelect.value);
      const beats = parseInt(this.#beatsSelect.value);
      const subdivisions = parseInt(this.#subdivisionsSelect.value);
      const pattern = parsePattern(this.#patternInput.value, beats, subdivisions);
      const prerollBars = parseInt(this.#prerollBarsSelect.value);

      this.#beeper = new Beeper({
        audioCtx: this.#audioCtx,
        tempo: tempo,
        beats: beats,
        subdivisions: subdivisions,
        pattern: pattern,
        queue: this.#queue,
        clicks: this.#clicks
      });

      this.#tracker = new Tracker({
        id: ++this.#trackerId,
        audioCtx: this.#audioCtx,
        queue: this.#queue,
        body: this.#body,
        progressExerciseDiv: this.#progressExerciseDiv,
        progressRepetitionDiv: this.#progressRepetitionDiv,
        progressBarDiv: this.#progressBarDiv,
        dotsDiv: this.#dotsDiv,
        exerciseOffset: exerciseOffset,
        exercises: exercises,
        repetitions: repetitions,
        bars: bars,
        prerollBars: prerollBars,
        startExercise: this.#startExercise,
        onFinished: () => this.#setMetronomeIdle()
      });

      this.#startExercise = 0;

      this.#tracker.start();
      this.#beeper.start();
    }

    #stopMetronome() {
      console.assert(this.#tracker && this.#beeper);

      if (this.#startStopBtn.textContent === STOP_CAPTION &&
        this.#tracker.lastExercise &&
        !confirm("Discard current progress? (OK to stop, Esc to restart current exercise with preroll)")) {
        const lastExercise = this.#tracker.lastExercise;
        this.#setMetronomeIdle();
        this.#startExercise = lastExercise;
        this.#startMetronome();
        return;
      }
      else {
        this.#setMetronomeIdle();
      }
    }

    #setMetronomeIdle() {
      if (this.#beeper) {
        this.#beeper.stop();
        this.#beeper = null;
      }

      if (this.#tracker) {
        this.#tracker.stop();
        this.#tracker = null;
      }

      this.#queue.clear();

      this.#body.classList.remove("last");
      this.#progressExerciseDiv.innerHTML = IDLE_HTML;
      this.#progressRepetitionDiv.innerHTML = IDLE_HTML;
      this.#progressBarDiv.innerHTML = IDLE_HTML;
      this.#dotsDiv.replaceChildren();

      this.#startStopBtn.textContent = START_CAPTION;
      this.#fields.disabled = false;

      this.#startExercise = 0;
    }
  }

  (() => new App(document, window))();
  //]]>
</script>

</html>
<!DOCTYPE html>
<html>

<head>
  <title>Stick Control Metronome</title>
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: Verdana, Geneva, Tahoma, sans-serif;
      margin: 0px;
      display: flex;
      height: 100vh;
      align-items: center;
      background-color: limegreen;
    }

    body.last {
      animation: blink 0.75s linear infinite;
    }

    @keyframes blink {
      0% {
        background-color: white;
      }

      50% {
        background-color: red;
      }

      100% {
        background-color: white;
      }
    }

    #container {
      width: fit-content;
      margin: 0 auto;
    }

    .dots {
      display: flex;
      min-width: 900px;
      height: 200px;
    }

    .dot {
      width: 125px;
      height: 125px;
      border-radius: 50%;
      border: 5px solid green;
      display: grid;
      align-items: center;
      text-align: center;
      font-size: 2em;
      margin: 20px;
      color: lime;
    }

    .current {
      background-color: lightgreen;
      color: darkgreen;
    }

    #progress-repetitions,
    #progress-bars {
      font-size: 5em;
    }

    #controls {
      display: flex;
    }

    #fields {
      display: inline;
      border: none;
    }

    #fields div {
      display: inline-block;
    }

    #fields label {
      display: block;
    }

    #fields input,
    #fields select {
      box-sizing: border-box;
      vertical-align: top;
      height: 32px;
      padding: 5px;
    }

    #buttons {
      align-content: center;
    }

    #buttons button {
      height: 32px;
    }

    #progress-exercise {
      font-size: 3em;
    }

    #progress-repetition,
    #progress-bar {
      font-size: 2em;
    }

    #preset-container {
      display: none !important;
    }
  </style>
</head>

<body>
  <div id="container">
    <div id="indicators">
      <div id="progress-exercise">&ndash;&ndash;&ndash;</div>
      <div id="progress-repetition">&ndash;&ndash;&ndash;</div>
      <div id="progress-bar">&ndash;&ndash;&ndash;</div>
      <div id="dots" class="dots"></div>
    </div>
    <div id="controls">
      <div id="buttons">
        <button id="start-stop">Start</button>
      </div>
      <fieldset id="fields">
        <div>
          &#9833;=<select id="tempo" title="Tempo in quarter notes per minute"></select>
          <label for="tempo">tempo</label>
        </div>
        <div>
          <input id="start-exercise" type="number" min="1" max="100" step="1" title="Start exercise">
          <label for="start-exercise">start</label>
        </div>
        <div>
          <input id="exercises" type="number" min="1" max="100" step="1" title="Number of exercises">
          <label for="exercises">exercises</label>
        </div>
        <div>
          <select id="repetitions" title="Number of repetitions per exercise">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="5">5</option>
            <option value="10">10</option>
            <option value="20">20</option>
            <option value="50">50</option>
          </select>
          <label for="repetitions">reps</label>
        </div>
        <div>
          <select id="bars" title="Number of bars per repetition"></select>
          <label for="bars">bars</label>
        </div>
        <div>
          <select id="beats" title="Beats (with subdivisions determines number of steps in pattern)"></select>
          <label for="beats">beats</label>
        </div>
        <div>
          <select id="subdivisions" title="Subdivisions (with beats determines number of steps in pattern)">
            <option value="1">&#9833;</option>
            <option value="2">&#9834;</option>
            <option value="4">&#119137;</option>
          </select>
          <label for="subdivisions">subs</label>
        </div>
        <div>
          <input id="pattern" type="text" title="Metronome pattern in REAPER-like format">
          <label for="pattern">pattern</label>
        </div>
        <div>
          <select id="preroll-bars" title="Number of preroll bars played before first exercise starts">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
          </select>
          <label for="preroll-bars">preroll</label>
        </div>
        <div id="preset-container">
          <select id="preset" title="Presets"></select>
          <label for="preset">presets</label>
        </div>
      </fieldset>
    </div>
  </div>
</body>

<script>
  //<![CDATA[
  "use strict";

  const SAVE_ID = -1;
  const REMOVE_ID = -2;
  const CLEAR_ID = -3;
  const IMPORT_ID = -4;
  const EXPORT_ID = -5;
  const RESET_ID = -6;

  const START_CAPTION = "Start";
  const STOP_CAPTION = "Stop";

  const Accent = Object.freeze({
    HIGH: "A",
    MEDIUM: "B",
    LOW: "C",
    SILENT: "D"
  });

  const BEEP_DURATION = 0.05;

  const DEFAULT_TEMPO = 120;
  const DEFAULT_START_EXERCISE = 1;
  const DEFAULT_EXERCISES = 24;
  const DEFAULT_REPETITIONS = 20;
  const DEFAULT_BARS = 2;
  const DEFAULT_BEATS = 4;
  const DEFAULT_SUBDIVISIONS = 2;
  const DEFAULT_PREROLL_BARS = 2;
  const DEFAULT_START_BAR = 0;

  const IDLE_HTML = "&ndash;&ndash;&ndash;";

  const OSCILLATOR_PADDING = 0.01;

  function h(s) {
    return new Option(s).innerHTML;
  }

  function attr(s) {
    return new Option(s).innerHTML.replace("\"", "&quot;");
  }

  function makeDefaultPattern(beats, subdivisions) {
    let pattern = "";
    for (let i = 0; i < beats; ++i) {
      if (i == 0) {
        pattern += Accent.HIGH;
      } else {
        pattern += Accent.MEDIUM;
      }

      for (let j = 0; j < subdivisions - 1; ++j) {
        pattern += Accent.LOW;
      }
    }

    console.assert(pattern.length == beats * subdivisions);
    return pattern;
  }

  function parsePattern(s, beats, subdivisions) {
    const len = beats * subdivisions;
    return s.substring(0, len).padEnd(len, "D");
  }

  function formatProgress(name, value, count, offset = null, getReady = false) {
    let s = offset === null ? `${name} ${value + 1} of ${count}` : `${name} ${value + offset + 1} (${value + 1} of ${count})`;
    if (getReady) {
      s += " (get ready!)";
    }
    return s;
  }

  class DecayingSawtoothClick {
    #frequency
    #volume

    static Builder(frequency, volume) {
      return new class {
        constructor() { }

        build(audioCtx) {
          return new DecayingSawtoothClick(frequency, volume);
        }
      }
    }

    constructor(frequency, volume) {
      this.#frequency = frequency;
      this.#volume = volume;
    }

    generate(audioCtx, startTime) {
      const endTime = startTime + BEEP_DURATION;

      const oscillator = audioCtx.createOscillator();
      oscillator.type = "sawtooth";
      oscillator.frequency.setValueAtTime(this.#frequency, startTime);
      oscillator.start(startTime);
      oscillator.stop(endTime + OSCILLATOR_PADDING);

      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(this.#volume, startTime);
      gain.gain.exponentialRampToValueAtTime(0.0001, endTime);

      oscillator.connect(gain).connect(audioCtx.destination);
    }
  }

  class FilteredWhiteNoiseClick {
    static #buffers = {};
    #buffer

    static Builder() {
      return new class {
        constructor() { }

        build(audioCtx) {
          const buffer = FilteredWhiteNoiseClick.#getBuffer(audioCtx);
          return new FilteredWhiteNoiseClick(buffer);
        }
      }
    }

    constructor(buffer) {
      this.#buffer = buffer;
    }

    generate(audioCtx, startTime) {
      const endTime = startTime + BEEP_DURATION;

      const noise = audioCtx.createBufferSource();
      noise.buffer = this.#buffer;
      noise.start(startTime);
      noise.stop(endTime);

      const filter = audioCtx.createBiquadFilter();
      filter.type = "highpass";
      filter.frequency.setValueAtTime(2000, audioCtx.currentTime);

      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0, startTime);
      gain.gain.linearRampToValueAtTime(1, startTime + 0.001);
      gain.gain.exponentialRampToValueAtTime(0.001, endTime);

      noise.connect(filter).connect(gain).connect(audioCtx.destination);
    }

    static #getBuffer(audioCtx) {
      const temp = FilteredWhiteNoiseClick.#buffers[audioCtx];
      if (temp !== undefined) { return temp; }

      const bufferLen = audioCtx.sampleRate * 0.5;
      const buffer = audioCtx.createBuffer(1, bufferLen, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferLen; ++i) {
        data[i] = Math.random() * 2 - 1;
      }

      FilteredWhiteNoiseClick.#buffers[audioCtx] = buffer;
      return buffer
    }
  }

  const PARAMS = new URLSearchParams(window.location.search);
  const SILENT = PARAMS.get("silent") == "1";
  const VOLUME = SILENT ? 0.0 : 1.0;
  const CLICKS = {
    [Accent.HIGH]: DecayingSawtoothClick.Builder(1760, VOLUME),
    [Accent.MEDIUM]: DecayingSawtoothClick.Builder(880, VOLUME),
    [Accent.LOW]: DecayingSawtoothClick.Builder(440, VOLUME),
    [Accent.SILENT]: null
  };

  class Queue {
    #notes = [];

    constructor() { }

    get isEmpty() { return this.#notes.length == 0; }

    enqueue(note) {
      this.#notes.push(note);
    }

    dequeue() {
      if (this.isEmpty) {
        return null;
      }

      return this.#notes.shift();
    }

    peek() {
      if (this.isEmpty) {
        return null;
      }
      return this.#notes[0];
    }

    clear() {
      this.#notes.length = 0;
    }
  }

  class Beeper {
    #audioCtx
    #tempo
    #beats
    #subdivisions
    #pattern
    #queue
    #interval
    #lookahead
    #stepInterval
    #nextStepTime = null;
    #step = null;
    #intervalId = null;
    #currentBar = null;
    #clicks

    constructor(options) {
      this.#audioCtx = options.audioCtx;
      this.#tempo = options.tempo;
      this.#beats = options.beats;
      this.#subdivisions = options.subdivisions;
      this.#pattern = options.pattern;
      this.#queue = options.queue;
      this.#interval = Object.hasOwn(options, "interval") ? options.interval : 30;
      this.#lookahead = Object.hasOwn(options, "lookahead") ? options.lookahead : 0.1;
      this.#stepInterval = 60 / this.#tempo / this.#subdivisions;
      this.#clicks = Object.keys(options.clicks).reduce((acc, k) => {
        const factory = options.clicks[k];
        const click = factory ? factory.build(this.#audioCtx) : null;
        acc[k] = click;
        return acc;
      }, {});
    }

    start() {
      this.stop();
      this.#nextStepTime = this.#audioCtx.currentTime;
      this.#step = 0;
      this.#intervalId = setInterval(() => { this.#scheduleBeeps() }, this.#interval);
      this.#currentBar = 0;
    }

    stop() {
      if (this.#intervalId) {
        clearInterval(this.#intervalId);
        this.#intervalId = null;
      }
    }

    #scheduleBeeps() {
      while (this.#nextStepTime < this.#audioCtx.currentTime + this.#lookahead) {
        this.#scheduleBeep();
        this.#nextStepTime += this.#stepInterval;
        this.#step = (this.#step + 1) % this.#pattern.length;
        if (this.#step == 0) {
          ++this.#currentBar;
        }
      }
    }

    #scheduleBeep() {
      if (this.#step % this.#subdivisions == 0) {
        const beat = Math.trunc(this.#step / this.#subdivisions);
        this.#queue.enqueue({
          beat: beat,
          beats: this.#beats,
          time: this.#nextStepTime,
          currentBar: this.#currentBar
        });
      }

      const click = this.#clicks[this.#pattern[this.#step]];
      if (click) {
        click.generate(this.#audioCtx, this.#nextStepTime)
      }
    }
  }

  class Tracker {
    #id
    #audioCtx
    #queue
    #body
    #progressExerciseDiv
    #progressRepetitionDiv
    #progressBarDiv
    #dotsDiv
    #exerciseOffset
    #exercises
    #repetitions
    #bars
    #prerollBars
    #startExercise
    #onFinished
    #requestIds = [];
    #beats = null;
    #lastExercise = 0;

    constructor(options) {
      this.#id = options.id;
      this.#audioCtx = options.audioCtx;
      this.#queue = options.queue;
      this.#body = options.body;
      this.#progressExerciseDiv = options.progressExerciseDiv;
      this.#progressRepetitionDiv = options.progressRepetitionDiv;
      this.#progressBarDiv = options.progressBarDiv;
      this.#dotsDiv = options.dotsDiv;
      this.#exerciseOffset = options.exerciseOffset;
      this.#exercises = options.exercises;
      this.#repetitions = options.repetitions;
      this.#bars = options.bars;
      this.#prerollBars = options.prerollBars;
      this.#startExercise = options.startExercise;
      this.#onFinished = options.onFinished;
    }

    get lastExercise() { return this.#lastExercise; }

    start() {
      this.#requestIds.push(window.requestAnimationFrame(() => this.#refresh()));
    }

    stop() {
      while (this.#requestIds.length > 0) {
        const requestId = this.#requestIds.pop();
        window.cancelAnimationFrame(requestId);
      }
    }

    #refresh() {
      const note = this.#nextNote();
      if (note) {
        if (!this.#update(note)) { return; }
      }
      this.#requestIds.push(window.requestAnimationFrame(() => this.#refresh()));
    }

    #nextNote() {
      const time = this.#audioCtx.currentTime;
      const note = this.#queue.peek();
      if (!note || note.time > time) { return null; }
      return this.#queue.dequeue();
    }

    #update(note) {
      if (note.beats != this.#beats) {
        this.#beats = note.beats;
        this.#dotsDiv.replaceChildren();
        for (let i = 0; i < this.#beats; ++i) {
          const e = document.createElement("div");
          e.innerHTML = (i + 1).toString();
          e.classList.add("dot");
          this.#dotsDiv.appendChild(e);
        }
      }

      [...this.#dotsDiv.children].forEach((e, i) => {
        if (i == note.beat) {
          e.classList.add("current");
        } else {
          e.classList.remove("current");
        }
      });

      let isLastBarOfRepetition;
      if (note.currentBar < this.#prerollBars) {
        isLastBarOfRepetition = note.currentBar == this.#prerollBars - 1;
        this.#progressExerciseDiv.innerHTML = `preroll &rarr; exercise ${this.#startExercise + this.#exerciseOffset + 1}`;
        this.#progressRepetitionDiv.innerHTML = IDLE_HTML;
        this.#progressBarDiv.innerHTML = formatProgress("bar", note.currentBar, this.#prerollBars, null, isLastBarOfRepetition);
      } else {
        const [exercise, repetition, bar] = this.#position(note.currentBar - this.#prerollBars);
        isLastBarOfRepetition = repetition == this.#repetitions - 1 && bar == this.#bars - 1;
        const isFinished = exercise >= this.#exercises;
        this.#progressExerciseDiv.innerHTML = formatProgress("exercise", exercise, this.#exercises, this.#exerciseOffset);
        this.#progressRepetitionDiv.innerHTML = formatProgress("rep", repetition, this.#repetitions);
        this.#progressBarDiv.innerHTML = formatProgress("bar", bar, this.#bars, null, isLastBarOfRepetition);
        this.#lastExercise = exercise;
        if (isFinished) {
          this.#onFinished();
          return false;
        }
      }

      if (isLastBarOfRepetition) {
        this.#body.classList.add("last");
      } else {
        this.#body.classList.remove("last");
      }

      return true;
    }

    #position(overallBar) {
      const barsInExercise = this.#bars * this.#repetitions;
      const exercise = Math.trunc(overallBar / barsInExercise) + this.#startExercise;
      const rem = overallBar % barsInExercise;
      const repetition = Math.trunc(rem / this.#bars);
      const bar = rem % this.#bars;
      return [exercise, repetition, bar];
    }
  }

  class App {
    #body
    #progressExerciseDiv
    #progressRepetitionDiv
    #progressBarDiv
    #dotsDiv
    #startStopBtn
    #fields
    #tempoSelect
    #startExerciseInput
    #exercisesInput
    #repetitionsSelect
    #barsSelect
    #beatsSelect
    #subdivisionsSelect
    #patternInput
    #prerollBarsSelect
    #trackerId = 0;
    #audioCtx = new AudioContext();
    #queue = new Queue();
    #startExercise = 0;
    #beeper = null;
    #tracker = null;
    #elements
    #defaultElementValues

    constructor(document) {
      this.#body = document.body;
      this.#progressExerciseDiv = document.getElementById("progress-exercise");
      this.#progressRepetitionDiv = document.getElementById("progress-repetition");
      this.#progressBarDiv = document.getElementById("progress-bar");
      this.#dotsDiv = document.getElementById("dots");
      this.#startStopBtn = document.getElementById("start-stop");
      this.#fields = document.getElementById("fields");
      this.#tempoSelect = document.getElementById("tempo");
      this.#startExerciseInput = document.getElementById("start-exercise");
      this.#exercisesInput = document.getElementById("exercises");
      this.#repetitionsSelect = document.getElementById("repetitions");
      this.#barsSelect = document.getElementById("bars");
      this.#beatsSelect = document.getElementById("beats");
      this.#subdivisionsSelect = document.getElementById("subdivisions");
      this.#patternInput = document.getElementById("pattern");
      this.#prerollBarsSelect = document.getElementById("preroll-bars");
      this.#elements = [
        this.#tempoSelect,
        this.#startExerciseInput,
        this.#exercisesInput,
        this.#repetitionsSelect,
        this.#barsSelect,
        this.#beatsSelect,
        this.#subdivisionsSelect,
        this.#patternInput,
        this.#prerollBarsSelect
      ].toSorted((a, b) => a.id.localeCompare(b.id));
      this.#defaultElementValues = {
        [this.#tempoSelect.id]: DEFAULT_TEMPO,
        [this.#startExerciseInput.id]: DEFAULT_START_EXERCISE,
        [this.#exercisesInput.id]: DEFAULT_EXERCISES,
        [this.#repetitionsSelect.id]: DEFAULT_REPETITIONS,
        [this.#barsSelect.id]: DEFAULT_BARS,
        [this.#beatsSelect.id]: DEFAULT_BEATS,
        [this.#subdivisionsSelect.id]: DEFAULT_SUBDIVISIONS,
        [this.#patternInput.id]: makeDefaultPattern(DEFAULT_BEATS, DEFAULT_SUBDIVISIONS),
        [this.#prerollBarsSelect.id]: DEFAULT_PREROLL_BARS
      };
      this.#initUi(document);
    }

    pushState() {
      const url = new URL(window.location);
      for (const e of this.#elements) {
        url.searchParams.set(e.id, e.value);
      }
      window.history.replaceState({}, "", url);
    }

    #initUi(document) {
      this.#progressExerciseDiv.innerHTML = IDLE_HTML;
      this.#progressRepetitionDiv.innerHTML = IDLE_HTML;
      this.#progressBarDiv.innerHTML = IDLE_HTML;
      this.#dotsDiv.replaceChildren();

      this.#populateSelect(document, this.#tempoSelect, 50, 250);
      this.#populateSelect(document, this.#barsSelect, 1, 4);
      this.#populateSelect(document, this.#beatsSelect, 1, 16);

      this.#startStopBtn.textContent = START_CAPTION;

      const params = new URLSearchParams(window.location.search);
      for (const e of this.#elements) {
        const value = params.get(e.id);
        e.value = value === null ? this.#defaultElementValues[e.id] : value;
      }

      const inputs = [
        this.#startExerciseInput,
        this.#exercisesInput,
      ];
      for (const input of inputs) {
        input.addEventListener("keydown", e => {
          if (e.key == "e") {
            e.preventDefault();
          }
        })
      }

      for (const e of this.#elements) {
        e.addEventListener("input", e => this.pushState());
      }

      this.#beatsSelect.addEventListener("input", e => {
        if (!e.target.validity.valid) { return; }
        const beats = parseInt(e.target.value);
        if (Number.isNaN(beats)) { return; }

        if (!this.#subdivisionsSelect.validity.valid) { return; }
        const subdivisions = parseInt(this.#subdivisionsSelect.value);
        if (Number.isNaN(subdivisions)) { return; }

        this.#patternInput.value = makeDefaultPattern(beats, subdivisions);
      });

      this.#subdivisionsSelect.addEventListener("input", e => {
        if (!e.target.validity.valid) { return; }
        const subdivisions = parseInt(e.target.value);
        if (Number.isNaN(subdivisions)) { return; }

        if (!this.#beatsSelect.validity.valid) { return; }
        const beats = parseInt(this.#beatsSelect.value);
        if (Number.isNaN(beats)) { return; }

        this.#patternInput.value = makeDefaultPattern(beats, subdivisions);
      });

      this.#startStopBtn.addEventListener("click", e => {
        if (e.target.textContent == START_CAPTION) {
          this.#startMetronome();
        }
        else if (e.target.textContent == STOP_CAPTION) {
          this.#stopMetronome();
        }
      });

      document.addEventListener("keydown", e => {
        if (e.key == " ") {
          if (this.#startStopBtn != document.activeElement) {
            this.#startStopBtn.click();
          }
        }
      });
    }

    #populateSelect(document, select, min, max) {
      select.replaceChildren();
      for (let i = min; i <= max; ++i) {
        const e = document.createElement("option");
        e.value = i;
        e.innerHTML = i.toString();
        select.appendChild(e);
      }
    }

    #startMetronome() {
      console.assert(!this.#tracker && !this.#beeper);

      this.#startStopBtn.textContent = STOP_CAPTION;
      this.#fields.disabled = true;

      const tempo = parseInt(this.#tempoSelect.value);
      const exerciseOffset = this.#startExerciseInput.valueAsNumber - 1;
      const exercises = this.#exercisesInput.valueAsNumber;
      const repetitions = parseInt(this.#repetitionsSelect.value);
      const bars = parseInt(this.#barsSelect.value);
      const beats = parseInt(this.#beatsSelect.value);
      const subdivisions = parseInt(this.#subdivisionsSelect.value);
      const pattern = parsePattern(this.#patternInput.value, beats, subdivisions);
      const prerollBars = parseInt(this.#prerollBarsSelect.value);

      this.#beeper = new Beeper({
        audioCtx: this.#audioCtx,
        tempo: tempo,
        beats: beats,
        subdivisions: subdivisions,
        pattern: pattern,
        queue: this.#queue,
        clicks: CLICKS
      });

      this.#tracker = new Tracker({
        id: ++this.#trackerId,
        audioCtx: this.#audioCtx,
        queue: this.#queue,
        body: this.#body,
        progressExerciseDiv: this.#progressExerciseDiv,
        progressRepetitionDiv: this.#progressRepetitionDiv,
        progressBarDiv: this.#progressBarDiv,
        dotsDiv: this.#dotsDiv,
        exerciseOffset: exerciseOffset,
        exercises: exercises,
        repetitions: repetitions,
        bars: bars,
        prerollBars: prerollBars,
        startExercise: this.#startExercise,
        onFinished: () => this.#setMetronomeIdle()
      });

      this.#startExercise = 0;

      this.#tracker.start();
      this.#beeper.start();
    }

    #stopMetronome() {
      console.assert(this.#tracker && this.#beeper);

      if (this.#startStopBtn.textContent == STOP_CAPTION &&
        this.#tracker.lastExercise &&
        !confirm("Discard current progress? (OK to stop, Esc to restart current exercise with preroll)")) {
        const lastExercise = this.#tracker.lastExercise;
        this.#setMetronomeIdle();
        this.#startExercise = lastExercise;
        this.#startMetronome();
        return;
      }
      else {
        this.#setMetronomeIdle();
      }
    }

    #setMetronomeIdle() {
      if (this.#beeper) {
        this.#beeper.stop();
        this.#beeper = null;
      }

      if (this.#tracker) {
        this.#tracker.stop();
        this.#tracker = null;
      }

      this.#queue.clear();

      this.#body.classList.remove("last");
      this.#progressExerciseDiv.innerHTML = IDLE_HTML;
      this.#progressRepetitionDiv.innerHTML = IDLE_HTML;
      this.#progressBarDiv.innerHTML = IDLE_HTML;
      this.#dotsDiv.replaceChildren();

      this.#startStopBtn.textContent = START_CAPTION;
      this.#fields.disabled = false;

      this.#startExercise = 0;
    }
  }

  (() => {
    function fetchPresets() {
      return fetch("data.json").then(response => {
        if (response.ok) {
          return response.json();
        } else {
          throw new Error(`Failed to retrieve data from ${response.url}`);
        }
      }).then(data => writePresets(Object.hasOwn(data, "presets") ? data.presets : []))
        .catch(console.error);
    }

    function readPresets() {
      const json = localStorage.getItem("presets");
      return json === null ? null : JSON.parse(json).toSorted((a, b) => a.name.localeCompare(b.name));
    }

    function writePresets(presets) {
      const json = JSON.stringify(presets.toSorted((a, b) => a.name.localeCompare(b.name)));
      localStorage.setItem("presets", json);
    }

    function runApp() {
      const app = new App(document);
      initializePresetsUi(app, document);
    }

    function initializePresetsUi(app, document) {
      const tempoSelect = document.getElementById("tempo");
      const startExerciseInput = document.getElementById("start-exercise");
      const exercisesInput = document.getElementById("exercises");
      const repetitionsSelect = document.getElementById("repetitions");
      const barsSelect = document.getElementById("bars");
      const beatsSelect = document.getElementById("beats");
      const subdivisionsSelect = document.getElementById("subdivisions");
      const patternInput = document.getElementById("pattern");
      const prerollBarsSelect = document.getElementById("preroll-bars");
      const presetContainerDiv = document.getElementById("preset-container");
      const presetSelect = document.getElementById("preset");

      populatePresetsUi(presetContainerDiv, presetSelect);

      presetSelect.addEventListener("change", e => {
        if (e.target.value.length > 0) {
          switch (parseInt(e.target.value)) {
            case SAVE_ID: {
              const name = prompt("Enter preset name");
              if (name !== null) {
                const presets = readPresets();
                presets.push({
                  name: name,
                  tempo: parseInt(tempoSelect.value),
                  startExercise: startExerciseInput.valueAsNumber,
                  exercises: exercisesInput.valueAsNumber,
                  repetitions: parseInt(repetitionsSelect.value),
                  bars: parseInt(barsSelect.value),
                  beats: parseInt(beatsSelect.value),
                  subdivisions: parseInt(subdivisionsSelect.value),
                  pattern: patternInput.value,
                  prerollBars: parseInt(prerollBarsSelect.value)
                });
                writePresets(presets);
                populatePresetsUi(presetContainerDiv, presetSelect);
              }
              break;
            }
            case REMOVE_ID: {
              const name = prompt("Enter preset name");
              if (name !== null) {
                writePresets(readPresets().filter(p => p.name.localeCompare(name)));
                populatePresetsUi(presetContainerDiv, presetSelect);
              }
              break;
            }
            case CLEAR_ID: {
              writePresets([]);
              populatePresetsUi(presetContainerDiv, presetSelect);
              break;
            }
            case IMPORT_ID: {
              const encoded = prompt("Enter preset state");
              if (encoded !== null) {
                const s = atob(encoded);
                const presets = JSON.parse(s);
                writePresets(presets);
                populatePresetsUi(presetContainerDiv, presetSelect);
              }
              break;
            }
            case EXPORT_ID: {
              const presets = readPresets();
              const s = JSON.stringify(presets);
              const encoded = btoa(s);
              navigator.clipboard.writeText(encoded).then(() => alert("Preset state written to clipboard!"));
              break;
            }
            case RESET_ID: {
              fetchPresets().then(() => populatePresetsUi(presetContainerDiv, presetSelect));
            }
          }
          return;
        }

        const selectedOption = e.target.options[e.target.selectedIndex];
        const preset = JSON.parse(selectedOption.dataset.presetJson);
        if (Object.hasOwn(preset, "tempo")) {
          tempoSelect.value = preset.tempo;
        }
        if (Object.hasOwn(preset, "startExercise")) {
          startExerciseInput.value = preset.startExercise;
        }
        if (Object.hasOwn(preset, "exercises")) {
          exercisesInput.value = preset.exercises;
        }
        if (Object.hasOwn(preset, "repetitions")) {
          repetitionsSelect.value = preset.repetitions;
        }
        if (Object.hasOwn(preset, "bars")) {
          barsSelect.value = preset.bars;
        }
        if (Object.hasOwn(preset, "beats")) {
          beatsSelect.value = preset.beats;
        }
        if (Object.hasOwn(preset, "subdivisions")) {
          subdivisionsSelect.value = preset.subdivisions;
        }
        if (Object.hasOwn(preset, "pattern")) {
          patternInput.value = preset.pattern;
        }
        if (Object.hasOwn(preset, "prerollBars")) {
          prerollBarsSelect.value = preset.prerollBars;
        }

        app.pushState();
      })
    }

    function populatePresetsUi(presetContainerDiv, presetSelect) {
      function specialOption(innerHtml, value = null, disabled = false) {
        const e = document.createElement("option");
        e.innerHTML = innerHtml;
        if (value) {
          e.value = value;
        }
        e.disabled = disabled;
        presetSelect.appendChild(e);
      }

      presetSelect.replaceChildren();

      for (const preset of readPresets()) {
        const e = document.createElement("option");
        e.innerHTML = h(preset.name);
        e.value = "";
        e.dataset.presetJson = JSON.stringify(preset);
        presetSelect.appendChild(e);
      }

      specialOption("__________", null, true);
      specialOption("Save current parameters as preset...", SAVE_ID);
      specialOption("Remove preset...", REMOVE_ID);
      specialOption("Clear presets", CLEAR_ID);
      specialOption("Import presets...", IMPORT_ID);
      specialOption("Export presets...", EXPORT_ID);
      specialOption("Reset presets to defaults", RESET_ID);

      presetContainerDiv.style.setProperty("display", "inline-block", "important");
      presetSelect.selectedIndex = -1;
    }

    if (readPresets() === null) {
      fetchPresets().then(runApp);
    } else {
      runApp();
    }
  })();
  //]]>
</script>

</html>